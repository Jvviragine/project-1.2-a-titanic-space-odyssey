Index: src/physics/simulation/TripSimulation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package physics.simulation;\n\nimport gui.screens.StartScreen;\nimport physics.optimalization.Corrections;\nimport physics.vectors.StateVector;\nimport physics.vectors.Vector;\nimport solar_system_data.InitialConditions;\nimport solar_system_data.PlanetaryData;\nimport physics.optimalization.FuelUsage;\n\nimport javax.swing.plaf.nimbus.State;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class TripSimulation {\n\n\n    public TripSimulation(){\n\n    }\n    double usedFuel = 0;\n    public void simulate(){\n        //Create a new simulation\n        SolarSystemPhysicsSimulation simulation = new SolarSystemPhysicsSimulation(PlanetaryData.getCelestialBodiesStateVector(),PlanetaryData.getCelestialBodiesMasses(),PlanetaryData.getCelestialBodyNames());\n        simulation.simulateOrbitsWithProbe(InitialConditions.getProbeInitialState(), StartScreen.simulationEndTime,StartScreen.h);\n\n        //Go through path and find the point at which the probe and titan are < 300km away from one another\n        //  Maybe make a greater distance and when it gets there start adjusting velocity ?\n        for(int i = 0; i < simulation.getPath().get(0).size(); i++){\n\n            //Get distance between probe and titan\n            double distance = (simulation.getPath().get(PlanetaryData.indexOf(\"Titan\")).get(i).getVector(0)).distance(simulation.getPath().get(simulation.getPath().size()-1).get(i).getVector(0));\n\n            //Check if close enough to enter orbit\n            if(distance <= 300) {\n\n                //Use titan and probe states when they are <=300km apart to adjust the velocity to get into orbit\n                StateVector titanState = simulation.getPath().get(PlanetaryData.indexOf(\"Titan\")).get(i);\n                StateVector probeState = simulation.getPath().get(simulation.getPath().size()-1).get(i);\n\n                //Initialise velocity correction\n                Corrections correct = new Corrections();\n\n                //Adjust new coordinates\n                StateVector newProbeState = correct.adjust(probeState,titanState,i*StartScreen.h, 31536000);\n\n                //Recalculate second part of path using current probe velocities\n                simulation.adjustPath(newProbeState,i*StartScreen.h, StartScreen.simulationEndTime,StartScreen.h);\n\n                //Have to have some condition to keep evaluating and changing direction (adjusting path)\n                \n                break;\n            }\n        }\n    }\n\n     public List<List<StateVector>> simulateTrip(){\n\n         List<List<StateVector>> orbits;\n         List<List<StateVector>> finalOrbits = new ArrayList<>();\n//         int tf = StartScreen.simulationEndTime;\n//         double h = StartScreen.h;\n         double h = 1800;\n         int tf = 31536000;\n\n         //simulation used to calculate the fuel for exiting earth and also to get earths position after two years\n         SolarSystemPhysicsSimulation simulationForSec = new SolarSystemPhysicsSimulation(PlanetaryData.getCelestialBodiesStateVector(),PlanetaryData.getCelestialBodiesMasses(),PlanetaryData.getCelestialBodyNames());\n         simulationForSec.simulateOrbitsWithProbe(InitialConditions.getProbeInitialState(), tf*2,h);\n\n         //calculating the time needed to exit earth to know how much fuel we use\n         double sec = 0;\n         for(int i = 0; i<simulationForSec.getPath().get(0).size();i++){\n             double dist = simulationForSec.getPath().get(4).get(i).getVector(0).distance(simulationForSec.getPath().get(11).get(i).getVector(0));\n             if(dist>6563000){\n                 sec = i*h;\n                 break;\n             }\n         }\n\n         //calculating used fuel and setting new velocity\n         Vector velF  = new Vector(new double[]{46.18781669742928, -44.638735761874045, -2.9953741584880706});\n         double sub = FuelUsage.fuelTakeoffLanding(InitialConditions.getInitialProbeVelocity().getMagnitude(), velF.getMagnitude(), sec);\n         usedFuel = usedFuel + sub;\n\n         InitialConditions.setProbeInitialVelocity(velF);\n\n         //start of the simulation to get to titan\n         SolarSystemPhysicsSimulation simulation = new SolarSystemPhysicsSimulation(PlanetaryData.getCelestialBodiesStateVector(),PlanetaryData.getCelestialBodiesMasses(),PlanetaryData.getCelestialBodyNames());\n         orbits = simulation.simulateOrbitsWithProbe(InitialConditions.getProbeInitialState(), tf,h);\n\n         for(int i = 0;i<orbits.get(0).size();i++){\n            //distance from the probe to titan\n            double dist = orbits.get(11).get(i).getVector(0).distance(orbits.get(8).get(i).getVector(0));\n            //checking if got to titan if so than setting up the simulation to get back, we never do??;(((((\n            if(dist<3000000){\n\n\n                int length = orbits.get(0).size()-1;\n                for(int j = length; j > i; j--){\n                    orbits.get(orbits.size()-1).remove(length);\n                    length--;\n                }\n                System.out.println(sec);\n                sec = i*h;\n\n\n                //making new state vectors for new simulation\n                StateVector[] newStateVectors = new StateVector[simulation.getStateVectors().length];\n                for(int j = 0; j<newStateVectors.length;j++){\n                    newStateVectors[j] = orbits.get(j).get(i);\n                }\n\n\n                //getting new velocity for the probe\n                Corrections correct = new Corrections();\n\n                //Adjust new coordinates\n                StateVector newProbeState = correct.adjust(simulation.getPath().get(11).get(i),simulationForSec.getPath().get(4).get(simulationForSec.getPath().get(4).size()-1),sec,tf*2);\n\n                //calculating fuel to adjust the new velocity\n                sub = FuelUsage.fuelTakeoffLanding(orbits.get(11).get(i).getVector(1).getMagnitude(), newProbeState.getVector(1).getMagnitude(), h);\n                usedFuel = usedFuel + sub;\n\n                System.out.print(newProbeState.getVector(1).get(0)+ \" \");\n                System.out.print(newProbeState.getVector(1).get(1)+ \" \");\n                System.out.println(newProbeState.getVector(1).get(2)+ \" \");\n\n                //setting up new simulation and running it with new State for probe (on titan)\n                SolarSystemPhysicsSimulation adjustedSimulation = new SolarSystemPhysicsSimulation(newStateVectors,PlanetaryData.getCelestialBodiesMasses(),PlanetaryData.getCelestialBodyNames());\n                List<List<StateVector>> adjustedOrbits = new ArrayList<>();\n                adjustedOrbits = adjustedSimulation.simulateOrbitsWithProbe(newProbeState,tf,h);\n                System.out.println(adjustedOrbits.get(0).size());\n\n                //creating the final orbits list\n                for(int j=0; j<orbits.size();j++){\n                    finalOrbits.add(new ArrayList<>());\n                    for(int k=0; k<orbits.get(j).size()*2;k++){\n                        Vector v = new Vector(new double[]{0,0,0});\n                        StateVector sv = new StateVector(new Vector[]{v,v});\n                        if(k<orbits.get(j).size()) {\n                            sv = orbits.get(j).get(k);\n                        }\n                        else{\n                            sv = adjustedOrbits.get(j).get(k-orbits.get(j).size());\n                        }\n                        finalOrbits.get(j).add(sv);\n\n                    }\n                }\n                System.out.println(finalOrbits.get(0).size());\n                break;\n            }\n         }\n         System.out.println(usedFuel);\n         return finalOrbits;\n     }\n\n    public static void main(String[] args) {\n        TripSimulation sim = new TripSimulation();\n        List<List<StateVector>> orb = sim.simulateTrip();\n        System.out.println(orb.get(11).get(orb.get(4).size()-1).getVector(0).get(0));\n        System.out.println(orb.get(11).get(orb.get(4).size()-1).getVector(0).get(1));\n        System.out.println(orb.get(11).get(orb.get(4).size()-1).getVector(0).get(2));\n        System.out.println(orb.get(4).get(orb.get(4).size()-1).getVector(0).get(0));\n        System.out.println(orb.get(4).get(orb.get(4).size()-1).getVector(0).get(1));\n        System.out.println(orb.get(4).get(orb.get(4).size()-1).getVector(0).get(2));\n        System.out.println(orb.get(4).get(orb.get(4).size()-1).getVector(0).distance(orb.get(11).get(orb.get(4).size()-1).getVector(0)));\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/physics/simulation/TripSimulation.java b/src/physics/simulation/TripSimulation.java
--- a/src/physics/simulation/TripSimulation.java	(revision 0c4217d455797510aec5516a5e3531c597ac5df6)
+++ b/src/physics/simulation/TripSimulation.java	(date 1685478689326)
@@ -142,7 +142,13 @@
                             sv = orbits.get(j).get(k);
                         }
                         else{
-                            sv = adjustedOrbits.get(j).get(k-orbits.get(j).size());
+                            sec+=h;
+                            if(j==11){
+                                sv = correct.adjust(adjustedOrbits.get(j).get(k-orbits.get(j).size()), simulationForSec.getPath().get(4).get(k-orbits.get(j).size()), sec, tf*2);
+                            }else {
+                                sv = adjustedOrbits.get(j).get(k - orbits.get(j).size());
+                            }
+                            //sv = adjustedOrbits.get(j).get(k - orbits.get(j).size());
                         }
                         finalOrbits.get(j).add(sv);
 
@@ -153,6 +159,7 @@
             }
          }
          System.out.println(usedFuel);
+         System.out.println(finalOrbits.get(2).size());
          return finalOrbits;
      }
 
